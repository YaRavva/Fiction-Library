# Механизм загрузки одиночного файла в bucket книг и установки связи с книгой

## Обзор

Этот документ описывает механизм загрузки одиночного файла из Telegram-канала "Архив для фантастики" в bucket книг Supabase Storage и установки связи с соответствующей книгой в базе данных.

## Требования

1. Типы файлов могут быть только `fb2` и `zip`
2. Имя файла в Storage должно иметь вид `<MessageID>.zip` (или `.fb2`)

## Этапы механизма загрузки

### 1. Подключение к Telegram

- Инициализация клиента Telegram с использованием учетных данных из переменных окружения
- Подключение к каналу "Архив для фантастики" по ID (1515159552)
- Получение сущности канала с использованием `Api.PeerChannel`

### 2. Получение файлов из канала

- Запрос последних сообщений из канала (ограничение по количеству)
- Поиск сообщений с медиа-файлами (документами)
- Извлечение информации о файле (оригинальное имя, расширение)

### 3. Проверка типа файла

- Извлечение расширения файла
- Проверка соответствия допустимым типам (`.fb2`, `.zip`)
- Отклонение файлов с недопустимыми расширениями

### 4. Скачивание файла

- Скачивание файла из Telegram с использованием `downloadMedia`
- Преобразование в Buffer для дальнейшей обработки

### 5. Формирование имени файла для Storage

- Создание имени файла в формате `<MessageID>.расширение`
- Гарантия уникальности имени файла в Storage

### 6. Определение MIME-типа

- Сопоставление расширения файла с MIME-типом:
  - `.fb2` → `application/fb2+xml`
  - `.zip` → `application/zip`

### 7. Загрузка файла в Supabase Storage

- Использование функции `uploadFileToStorage` для загрузки Buffer в bucket `books`
- Установка правильного MIME-типа
- Включение режима перезаписи (upsert)

### 8. Формирование URL файла

- Создание публичного URL для доступа к файлу:
  ```
  {supabaseUrl}/storage/v1/object/public/books/{storageFilename}
  ```

### 9. Обновление записи книги в базе данных

- Поиск соответствующей книги в базе данных (по автору и названию)
- Обновление полей книги:
  - `file_url` - URL файла в Storage
  - `file_size` - размер файла в байтах
  - `file_format` - формат файла (fb2 или zip)
  - `telegram_file_id` - ID сообщения в Telegram
  - `storage_path` - путь к файлу в Storage
  - `updated_at` - временная метка обновления

### 10. Обновление таблицы обработанных сообщений

- Обновление записи в таблице `telegram_processed_messages`
- Добавление поля `telegram_file_id` для отслеживания уже загруженных файлов
- Предотвращение повторной загрузки одних и тех же файлов

### 11. Проверка результата

- Проверка наличия файла в Storage
- Подтверждение успешного обновления записи книги
- Проверка обновления записи в таблице обработанных сообщений

## Интеграция с админ-панелью

### Загрузка файлов через админ-панель

В админ-панели реализована функция загрузки файлов с указанным лимитом:

1. Пользователь вводит количество файлов для загрузки в поле "Лимит публикаций"
2. При нажатии кнопки "Загрузить файлы" отправляется запрос на API endpoint `/api/admin/download-files` с указанным лимитом
3. Сервер получает файлы из Telegram-канала и загружает их в Storage
4. Для каждого файла устанавливается связь с соответствующей книгой в базе данных
5. Результаты операции отображаются в окне "Результаты последней операции"

### API Endpoints

- `POST /api/admin/download-files` - загрузка файлов с указанным лимитом
- `POST /api/admin/download-files-limit` - альтернативный endpoint для загрузки файлов с лимитом

### Пример использования

```typescript
// Подключение к Telegram
const telegramClient = new TelegramClient(session, apiId, apiHash);
await telegramClient.connect();

// Получение сущности канала
const channelEntity = await telegramClient.getEntity(
  new Api.PeerChannel({ channelId: bigInt(1515159552) })
);

// Получение сообщений
const messages = await telegramClient.getMessages(channelEntity, { limit: 5 });

// Поиск сообщения с файлом
const fileMessage = messages.find(msg => 
  (msg as any).media?.className === 'MessageMediaDocument'
);

// Скачивание файла
const fileBuffer = await telegramClient.downloadMedia(fileMessage, {});

// Формирование имени файла
const storageFilename = `${fileMessage.id}${fileExtension}`;

// Загрузка в Storage
await uploadFileToStorage('books', storageFilename, buffer, mimeType);

// Обновление записи книги
await supabase
  .from('books')
  .update({
    file_url: fileUrl,
    file_size: buffer.length,
    file_format: fileFormat,
    telegram_file_id: String(fileMessage.id),
    storage_path: storageFilename,
    updated_at: new Date().toISOString()
  })
  .eq('id', bookId);

// Обновление записи в таблице обработанных сообщений
await supabase
  .from('telegram_processed_messages')
  .update({
    telegram_file_id: String(fileMessage.id),
    processed_at: new Date().toISOString()
  })
  .eq('message_id', String(fileMessage.id));
```

## Обработка ошибок

Механизм включает обработку следующих типов ошибок:

1. **Ошибки подключения к Telegram** - повторные попытки подключения
2. **Ошибки доступа к каналу** - проверка прав доступа
3. **Ошибки скачивания файлов** - повторные попытки скачивания
4. **Ошибки загрузки в Storage** - логирование и повторные попытки
5. **Ошибки обновления базы данных** - откат изменений при необходимости
6. **Ошибки обновления таблицы обработанных сообщений** - логирование

## Особенности реализации

1. **Уникальность имен файлов** - использование MessageID гарантирует уникальность
2. **Типы файлов** - строгая проверка на допустимые форматы (fb2, zip)
3. **Метаданные** - извлечение автора и названия из имени файла
4. **Связь с книгой** - установка связи через обновление записи в базе данных
5. **Отслеживание обработанных файлов** - использование поля `telegram_file_id` в таблице `telegram_processed_messages`
6. **Проверка результата** - подтверждение успешной загрузки и обновления

## Заключение

Механизм загрузки одиночного файла полностью функционален и соответствует всем поставленным требованиям. Он обеспечивает:

- Корректную загрузку файлов только разрешенных типов
- Уникальные имена файлов в Storage
- Установку связи с соответствующими книгами в базе данных
- Обработку ошибок на всех этапах
- Проверку результата выполнения операций
- Интеграцию с админ-панелью для управления процессом загрузки
- Отслеживание уже обработанных файлов для предотвращения повторной загрузки