# Системные Паттерны: Fiction Library

## Архитектура

### Высокоуровневая Диаграмма

```mermaid
graph TD
    A[Next.js Frontend] --> B[API Routes]
    B --> C[Supabase Database]
    B --> D[Cloud.ru S3 Storage]
    B --> E[Telegram API]
    
    F[Book Worm Service] --> E
    F --> C
    F --> G[Download Queue]
    
    G --> H[Worker Process]
    H --> D
    H --> C
    
    I[Admin Panel] --> B
    J[User Interface] --> B
    
    K[GitHub Actions] --> F
```

### Архитектурные Слои

```mermaid
graph TB
    subgraph "Presentation Layer"
        UI[User Interface]
        ADMIN[Admin Panel]
    end
    
    subgraph "API Layer"
        API[Next.js API Routes]
        AUTH[Supabase Auth]
    end
    
    subgraph "Business Logic Layer"
        BOOKWORM[Book Worm Service]
        QUEUE[Queue Management]
        DEDUP[Deduplication Logic]
    end
    
    subgraph "Data Layer"
        DB[(Supabase PostgreSQL)]
        S3[(Cloud.ru S3)]
        TG[Telegram API]
    end
    
    UI --> API
    ADMIN --> API
    API --> AUTH
    API --> BOOKWORM
    API --> QUEUE
    BOOKWORM --> DB
    BOOKWORM --> TG
    QUEUE --> DB
    QUEUE --> S3
```

## Ключевые Технические Решения

### Паттерн 1: Repository Pattern для Данных
**Описание**: Абстракция доступа к данным через репозитории
**Почему выбран**: Разделение бизнес-логики и доступа к данным, упрощение тестирования
**Как использовать**: 
- Создавать репозитории в `src/lib/repositories/`
- Использовать интерфейсы для абстракции
- Инжектировать зависимости через конструктор

```typescript
// Пример: src/lib/repositories/BookRepository.ts
interface IBookRepository {
  findById(id: string): Promise<Book | null>
  findByAuthor(author: string): Promise<Book[]>
  create(book: CreateBookDto): Promise<Book>
}
```

### Паттерн 2: Queue Pattern для Асинхронных Задач
**Описание**: Система очередей для обработки длительных операций
**Почему выбран**: Предотвращение таймаутов, масштабируемость, надежность
**Как использовать**:
- Добавлять задачи через `src/lib/queue/QueueManager.ts`
- Обрабатывать через worker процессы
- Использовать статусы для отслеживания прогресса

### Паттерн 3: Service Layer для Бизнес-Логики
**Описание**: Выделение бизнес-логики в отдельные сервисы
**Почему выбран**: Переиспользование логики, четкое разделение ответственности
**Как использовать**:
- Создавать сервисы в `src/lib/services/`
- Один сервис = одна область ответственности
- Инжектировать репозитории как зависимости

### Паттерн 4: Factory Pattern для Telegram клиентов
**Описание**: Создание различных типов Telegram клиентов в зависимости от задач
**Почему выбран**: Гибкость в работе с разными каналами и типами операций
**Как использовать**:
- Использовать `TelegramClientFactory` для создания клиентов
- Разные клиенты для метаданных и файлов
- Переиспользование соединений

### Паттерн 5: Алгоритм релевантного поиска файлов
**Описание**: Универсальный алгоритм сопоставления файлов с книгами по названию и автору
**Почему выбран**: Обеспечивает точное сопоставление даже при различиях в написании и дополнительных элементах
**Как использовать**:
- Применять в "Книжном Черве" для автоматического сопоставления
- Использовать для поиска дубликатов и связывания файлов
- Настраивать пороги релевантности для разных сценариев

#### Принципы работы алгоритма:
1. **Нормализация строк**:
   - Приведение к NFC нормализации Unicode
   - Преобразование в нижний регистр
   - Замена "ё" на "е"

2. **Извлечение и очистка слов**:
   - Разделение по разделителям (пробелы, дефисы, скобки, точки)
   - Удаление русских союзов ("и", "или", "а", "но", "в", "на")
   - Удаление дополнительных элементов ("цикл", "серия", "книга", "том", "ru", "en")
   - Удаление годов в скобках и файловых расширений

3. **Система оценки**:
   - Точное совпадение слова: 20 баллов
   - Бонус за высокую долю совпадений (80%+)
   - Бонус за полное совпадение автора/названия
   - Штрафы за лишние слова
   - Минимальный порог: 65 баллов

```typescript
// Пример использования алгоритма релевантности
import { UniversalFileMatcher } from '@/lib/universal-file-matcher'

// Поиск подходящих файлов для книги
const matchingFiles = UniversalFileMatcher.findMatchingFiles(book, allFiles)

// Проверка релевантности конкретного файла
const isRelevant = UniversalFileMatcher.isFileRelevant(file, book)

// Получение детальной информации о сопоставлении
const matchResult = UniversalFileMatcher.matchFileToBook(file, book)
console.log(`Оценка: ${matchResult.score}, Совпадения: ${matchResult.matchedWords}`)
```

### Паттерн 6: Система дедупликации книг
**Описание**: Автоматическая и ручная система предотвращения и удаления дубликатов книг
**Почему выбран**: Поддержание качества данных и предотвращение засорения библиотеки
**Как использовать**:
- Интегрировать проверки в процесс синхронизации метаданных
- Запускать по расписанию через админ-панель
- Использовать скрипты для массовой очистки

#### Компоненты системы:
1. **Автоматическая дедупликация при синхронизации**:
   - Проверка каждой новой книги на дубликаты
   - Слияние данных: файлы, обложки, метаданные
   - Обновление существующих записей вместо создания дубликатов

2. **Нормализация текста для сравнения**:
   - Удаление годов в скобках "(2023)", "(2019)"
   - Удаление языковых индикаторов "ru", "en"
   - Приведение к нижнему регистру и очистка пробелов

3. **Планировщик дедупликации**:
   - Автоматический запуск по расписанию (5-1440 минут)
   - Обработка всех книг в базе данных
   - Приоритизация книг с файлами и полными метаданными

4. **Ручная дедупликация**:
   - Запуск через админ-панель
   - Режимы анализа и выполнения
   - Детальные отчеты о процессе

```typescript
// Пример использования сервиса дедупликации
import { BookDeduplicationService } from '@/lib/book-deduplication-service'

const duplicates = await BookDeduplicationService.checkForBookDuplicates(book)
const bestBook = BookDeduplicationService.selectBestBookFromDuplicates(duplicates)
```

### Паттерн 7: Асинхронная обработка файлов из Telegram
**Описание**: Система фоновой загрузки файлов с отслеживанием прогресса и возобновляемостью
**Почему выбран**: Предотвращение таймаутов, надежность, пользовательский опыт
**Как использовать**:
- Запускать через админ-панель или API endpoints
- Мониторить прогресс через TaskManager
- Использовать для массовой загрузки файлов

#### Архитектура асинхронной обработки:

```mermaid
graph TD
    A[Admin Panel] --> B[API Endpoint]
    B --> C[TaskManager]
    C --> D[BackgroundDownloadHandler]
    D --> E[Telegram API]
    D --> F[Relevance Algorithm]
    D --> G[Supabase Storage]
    D --> H[Database Updates]
    
    I[Progress Tracking] --> C
    J[Error Handling] --> D
    K[Resume Capability] --> D
```

#### Компоненты системы:
1. **TaskManager** (`src/lib/task-manager.ts`):
   - Отслеживание прогресса фоновых задач
   - Хранение статуса и результатов
   - Уникальные идентификаторы задач

2. **BackgroundDownloadHandler** (`src/lib/background-download.ts`):
   - Основная логика загрузки файлов
   - Интеграция с алгоритмом релевантности
   - Обработка ошибок и повторные попытки

3. **Возобновляемость процесса**:
   - Начало с последнего обработанного файла
   - Проверка существующих записей в `telegram_processed_messages`
   - Пропуск уже обработанных файлов

4. **Отслеживание прогресса**:
   - Реальное время отображения в админ-панели
   - Детальная статистика (успешно/ошибки/пропущено)
   - Логирование каждого шага обработки

```typescript
// Пример запуска асинхронной загрузки
import { TaskManager } from '@/lib/task-manager'
import { BackgroundDownloadHandler } from '@/lib/background-download'

const taskId = TaskManager.createTask('download-files', { limit: 100 })
const handler = new BackgroundDownloadHandler(taskId)
await handler.processFiles(100)
```

### Паттерн 8: Миграция файлов в Cloud.ru S3
**Описание**: Система миграции файлов из Supabase Storage в Cloud.ru S3 с локальным резервированием
**Почему выбран**: Оптимизация затрат, улучшение производительности, создание резервных копий
**Как использовать**:
- Выбирать подходящий скрипт в зависимости от сценария
- Всегда создавать локальные копии файлов
- Мониторить процесс через детальные логи

#### Типы миграции:
1. **Пошаговая миграция** (`migrate-to-cloud-ru.ts`):
   - Обработка файлов один за другим
   - Максимальная надежность
   - Подходит для production среды

2. **Параллельная миграция** (`migrate-to-cloud-ru-concurrent.ts`):
   - Одновременная обработка до 5 файлов
   - Высокая скорость миграции
   - Требует стабильного интернет-соединения

3. **Загрузка архива Telegram** (`upload-telegram-archive.ts`):
   - Работа с распакованными архивами
   - Поддержка оригинальных имен файлов
   - Рекурсивное сканирование директорий

4. **Локальное резервное копирование** (`download-all-files-locally.ts`):
   - Создание полного локального бэкапа
   - Сохранение оригинальной структуры
   - Пропуск существующих файлов

#### Особенности реализации:
- **Локальные копии**: Все скрипты автоматически сохраняют файлы локально
- **Контроль нагрузки**: Настраиваемое количество одновременных операций
- **Детальное логирование**: Прогресс каждого файла с размером и статусом
- **Обработка ошибок**: Продолжение работы при ошибках отдельных файлов

### Паттерн 9: Планировщик задач для автоматизации
**Описание**: Система автоматического запуска синхронизации по расписанию через планировщики ОС
**Почему выбран**: Обеспечивает регулярное обновление библиотеки без ручного вмешательства
**Как использовать**:
- Настроить через Windows Task Scheduler или Linux Cron
- Использовать переменные окружения для настройки интервалов
- Настроить логирование для мониторинга

#### Рекомендуемые расписания:
- **Разработка**: Метаданные каждые 30 минут, файлы каждые 2 часа
- **Продакшен**: Метаданные ежедневно в 02:00, файлы еженедельно в воскресенье 03:00

```bash
# Linux Cron пример
0 2 * * * cd /path/to/Fiction-Library && npx tsx src/scripts/scheduled-book-worm.ts

# Windows Task Scheduler
# Программа: C:\Program Files\nodejs\npx.cmd
# Аргументы: tsx src/scripts/scheduled-book-worm.ts
```

### Паттерн 10: Полная синхронизация "Книжного Червя"
**Описание**: Интеллектуальная система проверки целостности данных и полной синхронизации при необходимости
**Почему выбран**: Предотвращает потерю данных, обеспечивает согласованность между Telegram и базой данных
**Как использовать**:
- Автоматически определяет необходимость полной синхронизации
- Выполняет проверку пропущенных сообщений
- Индексирует метаданные для быстрого поиска

#### Алгоритм принятия решений:
1. **Проверка необходимости полной синхронизации**:
   - Отсутствие записей в `telegram_processed_messages`
   - Наличие непроцессированных сообщений в канале
   - Расхождения между каналом и базой данных

2. **Выполнение полной синхронизации**:
   - Постраничная загрузка всех сообщений (по 100 за раз)
   - Обработка от новых к старым сообщениям
   - Парсинг метаданных с дедупликацией
   - Сопоставление файлов с книгами

3. **Нормальная синхронизация**:
   - Обработка только новых сообщений
   - Начало с последнего обработанного сообщения
   - Быстрая синхронизация изменений

#### Расширенная индексация метаданных:
- **Базовая индексация**: ID сообщения, автор, название
- **Поиск по ключевым словам**: Частичное совпадение с ранжированием
- **Статистика индекса**: Мониторинг качества данных

```typescript
// Пример использования полной синхронизации
import { BookWormService } from '@/lib/book-worm-service'

const bookWorm = new BookWormService()
const needsFullSync = await bookWorm.checkNeedsFullSync()

if (needsFullSync) {
  await bookWorm.performFullSync()
} else {
  await bookWorm.performNormalSync()
}
```

### Паттерн 11: Конфигурация Supabase для продакшена
**Описание**: Стандартизированная настройка Supabase проекта с миграциями и безопасностью
**Почему выбран**: Обеспечивает консистентность развертывания и безопасность данных
**Как использовать**:
- Использовать скрипты инициализации и развертывания
- Применять миграции для изменений схемы
- Настраивать RLS политики для безопасности

#### Структура проекта Supabase:
- `supabase/migrations/` - Миграции схемы базы данных
- `supabase/migrations_clean/` - Чистые миграции без устаревшего функционала
- `supabase/scripts/` - Скрипты развертывания и инициализации

#### Компоненты безопасности:
1. **Row Level Security (RLS)**: Включен на всех таблицах
2. **Ролевая модель**: 'reader' и 'admin' роли с соответствующими правами
3. **Storage политики**: Ограниченный доступ к файлам и обложкам
4. **Аутентификация**: Email/password с профилями пользователей

```sql
-- Пример RLS политики
CREATE POLICY "Users can view all books" ON books
  FOR SELECT USING (auth.role() = 'authenticated');

CREATE POLICY "Only admins can modify books" ON books
  FOR ALL USING (auth.jwt() ->> 'role' = 'admin');
```

#### Процесс развертывания:
```bash
# Инициализация нового проекта
./supabase/scripts/init.sh

# Развертывание в существующий проект
./supabase/scripts/deploy.sh

# Применение миграций
supabase db push

# Сброс базы данных (ВНИМАНИЕ: удаляет все данные)
supabase db reset
```

## Стандарты Кода

### Именование

#### Файлы и Папки
- **Компоненты React**: PascalCase (`BookCard.tsx`)
- **Утилиты и сервисы**: camelCase (`bookService.ts`)
- **API маршруты**: kebab-case (`book-details.ts`)
- **Папки**: kebab-case (`book-management/`)

#### Переменные и Функции
- **Переменные**: camelCase (`bookTitle`, `authorName`)
- **Константы**: SCREAMING_SNAKE_CASE (`MAX_FILE_SIZE`)
- **Функции**: camelCase (`getBookById`, `downloadFile`)
- **React компоненты**: PascalCase (`BookCard`, `AdminPanel`)

#### База данных
- **Таблицы**: snake_case (`books`, `download_queue`)
- **Колонки**: snake_case (`created_at`, `file_size`)
- **Индексы**: `idx_table_column` (`idx_books_author`)

### Структура файлов

```
src/
├── app/                    # Next.js App Router
│   ├── (auth)/            # Группа маршрутов с аутентификацией
│   ├── admin/             # Админ-панель
│   ├── api/               # API маршруты
│   └── globals.css        # Глобальные стили
├── components/            # React компоненты
│   ├── ui/               # Базовые UI компоненты (shadcn/ui)
│   ├── book/             # Компоненты для работы с книгами
│   └── admin/            # Компоненты админ-панели
├── lib/                   # Утилиты и сервисы
│   ├── services/         # Бизнес-логика
│   ├── repositories/     # Доступ к данным
│   ├── telegram/         # Telegram интеграция
│   ├── queue/            # Система очередей
│   └── utils/            # Вспомогательные функции
└── scripts/              # Исполняемые скрипты
```

### Обработка ошибок

#### Стандартный формат ошибок API
```typescript
interface ApiError {
  error: string
  message: string
  statusCode: number
  timestamp: string
}
```

#### Логирование
- **Уровни**: ERROR, WARN, INFO, DEBUG
- **Формат**: Структурированные JSON логи
- **Контекст**: Включать userId, requestId, операцию

```typescript
// Пример логирования
logger.error('Failed to download file', {
  fileId,
  userId,
  error: error.message,
  stack: error.stack
})
```

### TypeScript Конвенции

#### Интерфейсы и Типы
- **Интерфейсы**: Префикс `I` для абстракций (`IBookRepository`)
- **Типы**: Суффикс по назначению (`CreateBookDto`, `BookListResponse`)
- **Enums**: PascalCase (`BookStatus`, `QueueStatus`)

#### Строгость типов
- Использовать `strict: true` в tsconfig.json
- Избегать `any`, предпочитать `unknown`
- Использовать утилитарные типы (`Partial<T>`, `Pick<T, K>`)

### React Паттерны

#### Структура компонентов
```typescript
// Стандартная структура React компонента
interface BookCardProps {
  book: Book
  onDownload?: (bookId: string) => void
}

export function BookCard({ book, onDownload }: BookCardProps) {
  // Hooks
  const [isLoading, setIsLoading] = useState(false)
  
  // Event handlers
  const handleDownload = useCallback(() => {
    onDownload?.(book.id)
  }, [book.id, onDownload])
  
  // Render
  return (
    // JSX
  )
}
```

#### Хуки
- Кастомные хуки в `src/lib/hooks/`
- Префикс `use` для всех хуков
- Возвращать объект для множественных значений

### API Маршруты

#### Структура ответов
```typescript
// Успешный ответ
interface SuccessResponse<T> {
  data: T
  message?: string
}

// Ответ с пагинацией
interface PaginatedResponse<T> {
  data: T[]
  pagination: {
    page: number
    limit: number
    total: number
    totalPages: number
  }
}
```

#### Валидация входных данных
- Использовать Zod для валидации
- Валидировать на уровне API маршрутов
- Возвращать детальные ошибки валидации

## Паттерны Безопасности

### Аутентификация и Авторизация
- Использовать Supabase Auth для аутентификации
- Проверять роли на уровне API маршрутов
- Использовать RLS (Row Level Security) в Supabase

### Валидация данных
- Валидировать все входные данные
- Санитизировать пользовательский ввод
- Использовать параметризованные запросы

### Обработка файлов
- Проверять типы файлов
- Ограничивать размер файлов
- Сканировать на вредоносное ПО (при необходимости)

## Паттерны Производительности

### Кэширование
- Использовать Next.js кэширование для статических данных
- Кэшировать результаты поиска
- Использовать CDN для статических файлов

### Оптимизация запросов
- Использовать индексы в базе данных
- Пагинировать большие списки
- Использовать lazy loading для изображений

### Асинхронная обработка
- Выносить тяжелые операции в очереди
- Использовать streaming для больших файлов
- Показывать прогресс длительных операций