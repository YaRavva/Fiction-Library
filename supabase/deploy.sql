-- Fiction Library: Consolidated Deployment Script
-- Generated by Gemini
--
-- This script combines all necessary migrations into a single file for deployment.
-- It has been ordered and cleaned based on analysis of the migration files.
-- Excluded migrations: 004_*, 012_clear_database.sql, 015_make_books_bucket_public.sql
-- The download queue from 005_* has been removed as requested.

-- From: 001_initial_schema.sql
-- Migration 001: Initial Schema Setup

-- Enable UUID extension
CREATE EXTENSION IF NOT EXISTS "uuid-ossp";

-- Enable Row Level Security
ALTER DEFAULT PRIVILEGES REVOKE EXECUTE ON FUNCTIONS FROM PUBLIC;

-- Series table (циклы книг)
CREATE TABLE series (
    id UUID PRIMARY KEY DEFAULT uuid_generate_v4(),
    title VARCHAR(500) NOT NULL,
    author VARCHAR(255) NOT NULL,
    description TEXT,
    rating DECIMAL(3,2) CHECK (rating >= 0 AND rating <= 10),
    cover_url VARCHAR(500),
    telegram_post_id VARCHAR(100),
    tags TEXT[] DEFAULT '{}',
    genres TEXT[] DEFAULT '{}',
    created_at TIMESTAMP WITH TIME ZONE DEFAULT NOW(),
    updated_at TIMESTAMP WITH TIME ZONE DEFAULT NOW()
);

-- Books table (отдельные книги)
CREATE TABLE books (
    id UUID PRIMARY KEY DEFAULT uuid_generate_v4(),
    series_id UUID REFERENCES series(id) ON DELETE SET NULL,
    title VARCHAR(500) NOT NULL,
    author VARCHAR(255) NOT NULL,
    publication_year INTEGER CHECK (publication_year > 1900 AND publication_year <= EXTRACT(YEAR FROM NOW()) + 10),
    description TEXT,
    cover_url VARCHAR(500),
    file_url VARCHAR(500),
    file_size BIGINT CHECK (file_size > 0),
    file_format VARCHAR(10) DEFAULT 'fb2' CHECK (file_format IN ('fb2', 'epub', 'pdf', 'txt')),
    rating DECIMAL(3,2) CHECK (rating >= 0 AND rating <= 10),
    tags TEXT[] DEFAULT '{}',
    genres TEXT[] DEFAULT '{}',
    series_order INTEGER CHECK (series_order > 0),
    telegram_file_id VARCHAR(100),
    downloads_count INTEGER DEFAULT 0 CHECK (downloads_count >= 0),
    views_count INTEGER DEFAULT 0 CHECK (views_count >= 0),
    created_at TIMESTAMP WITH TIME ZONE DEFAULT NOW(),
    updated_at TIMESTAMP WITH TIME ZONE DEFAULT NOW()
);

-- User profiles (расширение auth.users)
CREATE TABLE user_profiles (
    id UUID PRIMARY KEY REFERENCES auth.users(id) ON DELETE CASCADE,
    username VARCHAR(50),
    display_name VARCHAR(100),
    avatar_url VARCHAR(500),
    role VARCHAR(20) DEFAULT 'reader' CHECK (role IN ('reader', 'admin')),
    reading_preferences JSONB DEFAULT '{}',
    created_at TIMESTAMP WITH TIME ZONE DEFAULT NOW(),
    updated_at TIMESTAMP WITH TIME ZONE DEFAULT NOW(),
    UNIQUE(username)
);

-- User-Series relationships (избранные серии)
CREATE TABLE user_series (
    user_id UUID REFERENCES auth.users(id) ON DELETE CASCADE,
    series_id UUID REFERENCES series(id) ON DELETE CASCADE,
    is_favorite BOOLEAN DEFAULT FALSE,
    created_at TIMESTAMP WITH TIME ZONE DEFAULT NOW(),
    PRIMARY KEY (user_id, series_id)
);

-- User-Books relationships (избранные книги)
CREATE TABLE user_books (
    user_id UUID REFERENCES auth.users(id) ON DELETE CASCADE,
    book_id UUID REFERENCES books(id) ON DELETE CASCADE,
    is_favorite BOOLEAN DEFAULT FALSE,
    created_at TIMESTAMP WITH TIME ZONE DEFAULT NOW(),
    PRIMARY KEY (user_id, book_id)
);

-- Reading history (история чтения)
CREATE TABLE reading_history (
    id UUID PRIMARY KEY DEFAULT uuid_generate_v4(),
    user_id UUID REFERENCES auth.users(id) ON DELETE CASCADE,
    book_id UUID REFERENCES books(id) ON DELETE CASCADE,
    last_position INTEGER DEFAULT 0 CHECK (last_position >= 0),
    reading_progress DECIMAL(5,2) DEFAULT 0 CHECK (reading_progress >= 0 AND reading_progress <= 100),
    reading_time_minutes INTEGER DEFAULT 0 CHECK (reading_time_minutes >= 0),
    last_read_at TIMESTAMP WITH TIME ZONE DEFAULT NOW(),
    created_at TIMESTAMP WITH TIME ZONE DEFAULT NOW(),
    updated_at TIMESTAMP WITH TIME ZONE DEFAULT NOW(),
    UNIQUE(user_id, book_id)
);

-- User bookmarks (закладки)
CREATE TABLE user_bookmarks (
    id UUID PRIMARY KEY DEFAULT uuid_generate_v4(),
    user_id UUID REFERENCES auth.users(id) ON DELETE CASCADE,
    book_id UUID REFERENCES books(id) ON DELETE CASCADE,
    position INTEGER NOT NULL CHECK (position >= 0),
    chapter VARCHAR(255),
    note TEXT,
    created_at TIMESTAMP WITH TIME ZONE DEFAULT NOW()
);

-- User ratings and reviews (оценки и отзывы)
CREATE TABLE user_ratings (
    user_id UUID REFERENCES auth.users(id) ON DELETE CASCADE,
    book_id UUID REFERENCES books(id) ON DELETE CASCADE,
    rating INTEGER NOT NULL CHECK (rating >= 1 AND rating <= 10),
    review TEXT,
    created_at TIMESTAMP WITH TIME ZONE DEFAULT NOW(),
    updated_at TIMESTAMP WITH TIME ZONE DEFAULT NOW(),
    PRIMARY KEY (user_id, book_id)
);

-- Indexes for performance optimization
CREATE INDEX idx_books_author ON books(author);
CREATE INDEX idx_books_series ON books(series_id);
CREATE INDEX idx_books_genres ON books USING GIN(genres);
CREATE INDEX idx_books_tags ON books USING GIN(tags);
CREATE INDEX idx_books_publication_year ON books(publication_year);
CREATE INDEX idx_series_author ON series(author);
CREATE INDEX idx_series_genres ON series USING GIN(genres);
CREATE INDEX idx_series_tags ON series USING GIN(tags);
CREATE INDEX idx_reading_history_user ON reading_history(user_id);
CREATE INDEX idx_reading_history_book ON reading_history(book_id);
CREATE INDEX idx_user_bookmarks_user_book ON user_bookmarks(user_id, book_id);
CREATE INDEX idx_user_ratings_book ON user_ratings(book_id);

-- Full-text search indexes
CREATE INDEX idx_books_title_search ON books USING GIN(to_tsvector('russian', title));
CREATE INDEX idx_books_description_search ON books USING GIN(to_tsvector('russian', description));
CREATE INDEX idx_series_title_search ON series USING GIN(to_tsvector('russian', title));
CREATE INDEX idx_series_description_search ON series USING GIN(to_tsvector('russian', description));

-- Updated_at triggers
CREATE OR REPLACE FUNCTION update_updated_at_column()
RETURNS TRIGGER AS $$
BEGIN
    NEW.updated_at = NOW();
    RETURN NEW;
END;
$$ language 'plpgsql';

CREATE TRIGGER update_series_updated_at BEFORE UPDATE ON series
    FOR EACH ROW EXECUTE FUNCTION update_updated_at_column();

CREATE TRIGGER update_books_updated_at BEFORE UPDATE ON books
    FOR EACH ROW EXECUTE FUNCTION update_updated_at_column();

CREATE TRIGGER update_user_profiles_updated_at BEFORE UPDATE ON user_profiles
    FOR EACH ROW EXECUTE FUNCTION update_updated_at_column();

CREATE TRIGGER update_reading_history_updated_at BEFORE UPDATE ON reading_history
    FOR EACH ROW EXECUTE FUNCTION update_updated_at_column();

CREATE TRIGGER update_user_ratings_updated_at BEFORE UPDATE ON user_ratings
    FOR EACH ROW EXECUTE FUNCTION update_updated_at_column();

-- From: 002_security_policies.sql
-- Migration 002: Row Level Security Setup

-- Enable RLS on all tables
ALTER TABLE series ENABLE ROW LEVEL SECURITY;
ALTER TABLE books ENABLE ROW LEVEL SECURITY;
ALTER TABLE user_profiles ENABLE ROW LEVEL SECURITY;
ALTER TABLE user_series ENABLE ROW LEVEL SECURITY;
ALTER TABLE user_books ENABLE ROW LEVEL SECURITY;
ALTER TABLE reading_history ENABLE ROW LEVEL SECURITY;
ALTER TABLE user_bookmarks ENABLE ROW LEVEL SECURITY;
ALTER TABLE user_ratings ENABLE ROW LEVEL SECURITY;

-- Series policies (публичное чтение, админы могут изменять)
CREATE POLICY "Series are viewable by everyone" ON series
    FOR SELECT USING (true);

CREATE POLICY "Only admins can insert series" ON series
    FOR INSERT WITH CHECK (
        EXISTS (
            SELECT 1 FROM user_profiles 
            WHERE id = auth.uid() AND role = 'admin'
        )
    );

CREATE POLICY "Only admins can update series" ON series
    FOR UPDATE USING (
        EXISTS (
            SELECT 1 FROM user_profiles 
            WHERE id = auth.uid() AND role = 'admin'
        )
    );

CREATE POLICY "Only admins can delete series" ON series
    FOR DELETE USING (
        EXISTS (
            SELECT 1 FROM user_profiles 
            WHERE id = auth.uid() AND role = 'admin'
        )
    );

-- Books policies (публичное чтение, админы могут изменять)
CREATE POLICY "Books are viewable by everyone" ON books
    FOR SELECT USING (true);

CREATE POLICY "Only admins can insert books" ON books
    FOR INSERT WITH CHECK (
        EXISTS (
            SELECT 1 FROM user_profiles 
            WHERE id = auth.uid() AND role = 'admin'
        )
    );

CREATE POLICY "Only admins can update books" ON books
    FOR UPDATE USING (
        EXISTS (
            SELECT 1 FROM user_profiles 
            WHERE id = auth.uid() AND role = 'admin'
        )
    );

CREATE POLICY "Only admins can delete books" ON books
    FOR DELETE USING (
        EXISTS (
            SELECT 1 FROM user_profiles 
            WHERE id = auth.uid() AND role = 'admin'
        )
    );

-- User profiles policies
CREATE POLICY "Users can view all profiles" ON user_profiles
    FOR SELECT USING (true);

CREATE POLICY "Users can insert their own profile" ON user_profiles
    FOR INSERT WITH CHECK (auth.uid() = id);

CREATE POLICY "Users can update their own profile" ON user_profiles
    FOR UPDATE USING (auth.uid() = id);

CREATE POLICY "Only admins can delete profiles" ON user_profiles
    FOR DELETE USING (
        EXISTS (
            SELECT 1 FROM user_profiles 
            WHERE id = auth.uid() AND role = 'admin'
        )
    );

-- User-Series policies (только владелец)
CREATE POLICY "Users can view their own series relationships" ON user_series
    FOR SELECT USING (auth.uid() = user_id);

CREATE POLICY "Users can insert their own series relationships" ON user_series
    FOR INSERT WITH CHECK (auth.uid() = user_id);

CREATE POLICY "Users can update their own series relationships" ON user_series
    FOR UPDATE USING (auth.uid() = user_id);

CREATE POLICY "Users can delete their own series relationships" ON user_series
    FOR DELETE USING (auth.uid() = user_id);

-- User-Books policies (только владелец)
CREATE POLICY "Users can view their own book relationships" ON user_books
    FOR SELECT USING (auth.uid() = user_id);

CREATE POLICY "Users can insert their own book relationships" ON user_books
    FOR INSERT WITH CHECK (auth.uid() = user_id);

CREATE POLICY "Users can update their own book relationships" ON user_books
    FOR UPDATE USING (auth.uid() = user_id);

CREATE POLICY "Users can delete their own book relationships" ON user_books
    FOR DELETE USING (auth.uid() = user_id);

-- Reading history policies (только владелец)
CREATE POLICY "Users can view their own reading history" ON reading_history
    FOR SELECT USING (auth.uid() = user_id);

CREATE POLICY "Users can insert their own reading history" ON reading_history
    FOR INSERT WITH CHECK (auth.uid() = user_id);

CREATE POLICY "Users can update their own reading history" ON reading_history
    FOR UPDATE USING (auth.uid() = user_id);

CREATE POLICY "Users can delete their own reading history" ON reading_history
    FOR DELETE USING (auth.uid() = user_id);

-- User bookmarks policies (только владелец)
CREATE POLICY "Users can view their own bookmarks" ON user_bookmarks
    FOR SELECT USING (auth.uid() = user_id);

CREATE POLICY "Users can insert their own bookmarks" ON user_bookmarks
    FOR INSERT WITH CHECK (auth.uid() = user_id);

CREATE POLICY "Users can update their own bookmarks" ON user_bookmarks
    FOR UPDATE USING (auth.uid() = user_id);

CREATE POLICY "Users can delete their own bookmarks" ON user_bookmarks
    FOR DELETE USING (auth.uid() = user_id);

-- User ratings policies (публичное чтение, только владелец может изменять)
CREATE POLICY "Everyone can view ratings" ON user_ratings
    FOR SELECT USING (true);

CREATE POLICY "Users can insert their own ratings" ON user_ratings
    FOR INSERT WITH CHECK (auth.uid() = user_id);

CREATE POLICY "Users can update their own ratings" ON user_ratings
    FOR UPDATE USING (auth.uid() = user_id);

CREATE POLICY "Users can delete their own ratings" ON user_ratings
    FOR DELETE USING (auth.uid() = user_id);

-- Function to create user profile on signup
CREATE OR REPLACE FUNCTION public.handle_new_user()
RETURNS trigger AS $$
BEGIN
    INSERT INTO public.user_profiles (id, username, display_name, role)
    VALUES (
        new.id,
        COALESCE(new.raw_user_meta_data->>'username', split_part(new.email, '@', 1)),
        COALESCE(new.raw_user_meta_data->>'display_name', split_part(new.email, '@', 1)),
        'reader'
    );
    RETURN new;
END;
$$ language plpgsql security definer;

-- Trigger to create profile on user signup
CREATE TRIGGER on_auth_user_created
    AFTER INSERT ON auth.users
    FOR EACH ROW EXECUTE FUNCTION public.handle_new_user();

-- From: 003_utility_functions.sql
-- Migration 003: Utility Functions

-- Function to increment downloads count
CREATE OR REPLACE FUNCTION increment_downloads(book_id UUID)
RETURNS void AS $$
BEGIN
    UPDATE books 
    SET downloads_count = downloads_count + 1,
        updated_at = NOW()
    WHERE id = book_id;
END;
$$ LANGUAGE plpgsql;

-- Function to increment views count
CREATE OR REPLACE FUNCTION increment_views(book_id UUID)
RETURNS void AS $$
BEGIN
    UPDATE books 
    SET views_count = views_count + 1,
        updated_at = NOW()
    WHERE id = book_id;
END;
$$ LANGUAGE plpgsql;

-- Function for full-text search
CREATE OR REPLACE FUNCTION search_content(
    search_query TEXT,
    limit_count INTEGER DEFAULT 50
)
RETURNS TABLE (
    id UUID,
    title VARCHAR(500),
    author VARCHAR(255),
    description TEXT,
    type VARCHAR(10), -- 'book' or 'series'
    cover_url VARCHAR(500),
    rating DECIMAL(3,2),
    rank REAL
) AS $$
BEGIN
    RETURN QUERY
    (
        -- Search in books
        SELECT 
            b.id,
            b.title,
            b.author,
            b.description,
            'book'::VARCHAR(10) as type,
            b.cover_url,
            b.rating,
            ts_rank(
                to_tsvector('russian', COALESCE(b.title, '') || ' ' || COALESCE(b.author, '') || ' ' || COALESCE(b.description, '')),
                plainto_tsquery('russian', search_query)
            ) as rank
        FROM books b
        WHERE to_tsvector('russian', COALESCE(b.title, '') || ' ' || COALESCE(b.author, '') || ' ' || COALESCE(b.description, '')) 
              @@ plainto_tsquery('russian', search_query)
        
        UNION ALL
        
        -- Search in series
        SELECT 
            s.id,
            s.title,
            s.author,
            s.description,
            'series'::VARCHAR(10) as type,
            s.cover_url,
            s.rating,
            ts_rank(
                to_tsvector('russian', COALESCE(s.title, '') || ' ' || COALESCE(s.author, '') || ' ' || COALESCE(s.description, '')),
                plainto_tsquery('russian', search_query)
            ) as rank
        FROM series s
        WHERE to_tsvector('russian', COALESCE(s.title, '') || ' ' || COALESCE(s.author, '') || ' ' || COALESCE(s.description, '')) 
              @@ plainto_tsquery('russian', search_query)
    )
    ORDER BY rank DESC
    LIMIT limit_count;
END;
$$ LANGUAGE plpgsql;

-- Function to get book recommendations for user
CREATE OR REPLACE FUNCTION get_book_recommendations(
    user_id UUID,
    limit_count INTEGER DEFAULT 10
)
RETURNS TABLE (
    id UUID,
    title VARCHAR(500),
    author VARCHAR(255),
    description TEXT,
    cover_url VARCHAR(500),
    rating DECIMAL(3,2),
    recommendation_score REAL
) AS $$
BEGIN
    RETURN QUERY
    SELECT 
        b.id,
        b.title,
        b.author,
        b.description,
        b.cover_url,
        b.rating,
        -- Simple recommendation based on genres and authors from user's favorites
        (
            CASE 
                WHEN EXISTS (
                    SELECT 1 FROM user_books ub 
                    JOIN books fav_b ON ub.book_id = fav_b.id 
                    WHERE ub.user_id = get_book_recommendations.user_id 
                    AND ub.is_favorite = true 
                    AND fav_b.author = b.author
                ) THEN 3.0
                WHEN b.genres && ARRAY(
                    SELECT DISTINCT unnest(fav_b.genres)
                    FROM user_books ub 
                    JOIN books fav_b ON ub.book_id = fav_b.id 
                    WHERE ub.user_id = get_book_recommendations.user_id 
                    AND ub.is_favorite = true
                ) THEN 2.0
                ELSE 1.0
            END
            + COALESCE(b.rating, 0) * 0.1
            + (b.downloads_count::REAL / 1000.0)
        ) as recommendation_score
    FROM books b
    WHERE NOT EXISTS (
        SELECT 1 FROM user_books ub 
        WHERE ub.user_id = get_book_recommendations.user_id 
        AND ub.book_id = b.id
    )
    ORDER BY recommendation_score DESC
    LIMIT limit_count;
END;
$$ LANGUAGE plpgsql;

-- Function to get user reading statistics
CREATE OR REPLACE FUNCTION get_user_reading_stats(user_id UUID)
RETURNS TABLE (
    total_books_read INTEGER,
    total_reading_time_hours DECIMAL(10,2),
    favorite_genres TEXT[],
    current_streak_days INTEGER,
    books_this_month INTEGER
) AS $$
BEGIN
    RETURN QUERY
    SELECT 
        COUNT(DISTINCT rh.book_id)::INTEGER as total_books_read,
        ROUND(SUM(rh.reading_time_minutes) / 60.0, 2) as total_reading_time_hours,
        ARRAY(
            SELECT genre 
            FROM (
                SELECT unnest(b.genres) as genre, COUNT(*) as cnt
                FROM reading_history rh
                JOIN books b ON rh.book_id = b.id
                WHERE rh.user_id = get_user_reading_stats.user_id
                GROUP BY genre
                ORDER BY cnt DESC
                LIMIT 5
            ) t
        ) as favorite_genres,
        (
            SELECT COUNT(*)::INTEGER
            FROM (
                SELECT DISTINCT DATE(last_read_at)
                FROM reading_history
                WHERE user_id = get_user_reading_stats.user_id
                AND last_read_at >= CURRENT_DATE - INTERVAL '30 days'
                ORDER BY DATE(last_read_at) DESC
            ) daily_reads
        ) as current_streak_days,
        (
            SELECT COUNT(DISTINCT book_id)::INTEGER
            FROM reading_history
            WHERE user_id = get_user_reading_stats.user_id
            AND last_read_at >= DATE_TRUNC('month', CURRENT_DATE)
        ) as books_this_month
    FROM reading_history rh
    WHERE rh.user_id = get_user_reading_stats.user_id;
END;
$$ LANGUAGE plpgsql;

-- Function to get popular books
CREATE OR REPLACE FUNCTION get_popular_books(
    time_period VARCHAR(20) DEFAULT 'all_time', -- 'week', 'month', 'year', 'all_time'
    limit_count INTEGER DEFAULT 20
)
RETURNS TABLE (
    id UUID,
    title VARCHAR(500),
    author VARCHAR(255),
    description TEXT,
    cover_url VARCHAR(500),
    rating DECIMAL(3,2),
    downloads_count INTEGER,
    views_count INTEGER,
    popularity_score REAL
) AS $$
DECLARE
    date_filter TIMESTAMP WITH TIME ZONE;
BEGIN
    -- Set date filter based on time period
    CASE time_period
        WHEN 'week' THEN date_filter := NOW() - INTERVAL '7 days';
        WHEN 'month' THEN date_filter := NOW() - INTERVAL '30 days';
        WHEN 'year' THEN date_filter := NOW() - INTERVAL '365 days';
        ELSE date_filter := '1970-01-01'::TIMESTAMP WITH TIME ZONE;
    END CASE;

    RETURN QUERY
    SELECT 
        b.id,
        b.title,
        b.author,
        b.description,
        b.cover_url,
        b.rating,
        b.downloads_count,
        b.views_count,
        (
            b.downloads_count * 2.0 +
            b.views_count * 1.0 +
            COALESCE(b.rating, 0) * 10.0 +
            EXTRACT(EPOCH FROM (NOW() - b.created_at)) / 86400.0 * (-0.1) -- Slightly prefer newer books
        ) as popularity_score
    FROM books b
    WHERE b.created_at >= date_filter
    ORDER BY popularity_score DESC
    LIMIT limit_count;
END;
$$ LANGUAGE plpgsql;

-- From: 005_telegram_sync.sql (Partial)
-- Migration 005: Telegram Sync Support (excluding download queue)

-- First add missing telegram_post_id columns
ALTER TABLE books ADD COLUMN IF NOT EXISTS telegram_post_id VARCHAR(100);
ALTER TABLE series ADD COLUMN IF NOT EXISTS telegram_post_id VARCHAR(100);

-- Telegram sync status (статус синхронизации)
CREATE TABLE telegram_sync_status (
    id UUID PRIMARY KEY DEFAULT uuid_generate_v4(),
    channel_id VARCHAR(100) NOT NULL,
    last_message_id VARCHAR(100),
    last_sync_at TIMESTAMP WITH TIME ZONE DEFAULT NOW(),
    error_count INTEGER DEFAULT 0 CHECK (error_count >= 0),
    is_active BOOLEAN DEFAULT TRUE,
    created_at TIMESTAMP WITH TIME ZONE DEFAULT NOW(),
    updated_at TIMESTAMP WITH TIME ZONE DEFAULT NOW(),
    UNIQUE(channel_id)
);

-- Add new columns to books and series tables
ALTER TABLE books 
    ADD COLUMN IF NOT EXISTS telegram_channel_id VARCHAR(100),
    ADD COLUMN IF NOT EXISTS sync_status VARCHAR(20) DEFAULT 'synced' CHECK (sync_status IN ('pending', 'synced', 'failed')),
    ADD COLUMN IF NOT EXISTS sync_error TEXT;

ALTER TABLE series
    ADD COLUMN IF NOT EXISTS telegram_channel_id VARCHAR(100),
    ADD COLUMN IF NOT EXISTS sync_status VARCHAR(20) DEFAULT 'synced' CHECK (sync_status IN ('pending', 'synced', 'failed')),
    ADD COLUMN IF NOT EXISTS sync_error TEXT;

-- Create indexes for better performance
CREATE INDEX IF NOT EXISTS idx_books_telegram_sync ON books (telegram_channel_id, telegram_post_id) WHERE telegram_channel_id IS NOT NULL;
CREATE INDEX IF NOT EXISTS idx_series_telegram_sync ON series (telegram_channel_id, telegram_post_id) WHERE telegram_channel_id IS NOT NULL;

-- Security policies
ALTER TABLE telegram_sync_status ENABLE ROW LEVEL SECURITY;

-- Only admin can manage sync status
CREATE POLICY "Admin can manage sync status"
    ON telegram_sync_status
    FOR ALL
    TO authenticated
    USING (
        -- Allow service role
        current_user = 'authenticator' 
        OR
        -- Allow admin users
        EXISTS (
            SELECT 1 FROM user_profiles up 
            WHERE up.id = auth.uid() 
            AND up.role = 'admin'
        )
    );

-- From: 006_covers_storage.sql
-- Migration 006: Covers Storage Bucket

-- Создание bucket для обложек книг
INSERT INTO storage.buckets (id, name, public)
VALUES ('covers', 'covers', true)
ON CONFLICT (id) DO NOTHING;

-- From: 007_covers_storage_policies.sql
-- Migration 007: Covers Storage Policies

-- Политика: Публичный доступ на чтение для всех
CREATE POLICY "Public read access for covers"
ON storage.objects
FOR SELECT
USING (bucket_id = 'covers');

-- Политика: Загрузка файлов только для аутентифицированных пользователей
CREATE POLICY "Authenticated users can upload covers"
ON storage.objects
FOR INSERT
TO authenticated
WITH CHECK (bucket_id = 'covers');

-- Политика: Обновление файлов только для аутентифицированных пользователей
CREATE POLICY "Authenticated users can update covers"
ON storage.objects
FOR UPDATE
TO authenticated
USING (bucket_id = 'covers')
WITH CHECK (bucket_id = 'covers');

-- Политика: Удаление файлов только для аутентифицированных пользователей
CREATE POLICY "Authenticated users can delete covers"
ON storage.objects
FOR DELETE
TO authenticated
USING (bucket_id = 'covers');

-- From: 008_fix_series_schema.sql
-- Migration: Fix series table schema to add missing columns

-- Add series_composition column to store books composition
ALTER TABLE series 
ADD COLUMN IF NOT EXISTS series_composition JSONB DEFAULT '[]';

-- Add cover_urls column to store all cover images for the series
ALTER TABLE series 
ADD COLUMN IF NOT EXISTS cover_urls TEXT[] DEFAULT '{}';

-- Create indexes for better performance
CREATE INDEX IF NOT EXISTS idx_series_composition ON series USING GIN(series_composition);
CREATE INDEX IF NOT EXISTS idx_series_cover_urls ON series USING GIN(cover_urls);

-- Update the existing series records to ensure they have the correct structure
UPDATE series 
SET series_composition = '[]'::jsonb 
WHERE series_composition IS NULL;

UPDATE series 
SET cover_urls = '{}'::text[] 
WHERE cover_urls IS NULL;

-- From: 009_fix_books_series.sql
-- Migration: Fix books table to ensure proper series association

-- Make sure series_id column exists and has proper constraints
ALTER TABLE books 
ALTER COLUMN series_id TYPE UUID USING series_id::UUID;

-- Add index for better performance on series_id
CREATE INDEX IF NOT EXISTS idx_books_series_id ON books(series_id);

-- Update any books that might have incorrect series associations
UPDATE books 
SET series_id = NULL 
WHERE series_id IS NOT NULL 
AND NOT EXISTS (
    SELECT 1 FROM series WHERE series.id = books.series_id
);

-- From: 010_add_series_indexes.sql
-- Migration: Add additional indexes for better series and books performance

-- Index for series title and author for faster lookups
CREATE INDEX IF NOT EXISTS idx_series_title_author ON series(title, author);

-- Index for books title and author for faster lookups
CREATE INDEX IF NOT EXISTS idx_books_title_author ON books(title, author);

-- Index for books publication year for sorting
CREATE INDEX IF NOT EXISTS idx_books_publication_year_desc ON books(publication_year DESC);

-- Index for series rating for sorting
CREATE INDEX IF NOT EXISTS idx_series_rating_desc ON series(rating DESC NULLS LAST);

-- Index for books rating for sorting
CREATE INDEX IF NOT EXISTS idx_books_rating_desc ON books(rating DESC NULLS LAST);

-- Index for series created_at for sorting by date
CREATE INDEX IF NOT EXISTS idx_series_created_at_desc ON series(created_at DESC);

-- Index for books created_at for sorting by date
CREATE INDEX IF NOT EXISTS idx_books_created_at_desc ON books(created_at DESC);

-- From: 011_remove_book_duplicates.sql
-- Migration: Remove duplicate books from the database

WITH duplicates AS (
  SELECT 
    id,
    ROW_NUMBER() OVER (
      PARTITION BY title, author 
      ORDER BY created_at ASC
    ) as rn
  FROM books
)
DELETE FROM books 
WHERE id IN (
  SELECT id 
  FROM duplicates 
  WHERE rn > 1
);

-- From: 012_add_timer_settings.sql
-- Migration: Add timer settings table

CREATE TABLE IF NOT EXISTS timer_settings (
    id UUID PRIMARY KEY DEFAULT uuid_generate_v4(),
    process_name VARCHAR(100) NOT NULL UNIQUE,
    enabled BOOLEAN DEFAULT false,
    interval_minutes INTEGER DEFAULT 60 CHECK (interval_minutes >= 1 AND interval_minutes <= 1440),
    last_run TIMESTAMP WITH TIME ZONE,
    next_run TIMESTAMP WITH TIME ZONE,
    created_at TIMESTAMP WITH TIME ZONE DEFAULT NOW(),
    updated_at TIMESTAMP WITH TIME ZONE DEFAULT NOW()
);

INSERT INTO timer_settings (process_name, enabled, interval_minutes)
VALUES 
    ('deduplication', false, 60),
    ('channel_sync', false, 30),
    ('file_download', false, 15)
ON CONFLICT (process_name) DO NOTHING;

CREATE INDEX IF NOT EXISTS idx_timer_settings_process_name ON timer_settings(process_name);
CREATE INDEX IF NOT EXISTS idx_timer_settings_next_run ON timer_settings(next_run) WHERE enabled = true;

CREATE TRIGGER update_timer_settings_updated_at 
    BEFORE UPDATE ON timer_settings
    FOR EACH ROW 
    EXECUTE FUNCTION update_updated_at_column();

-- From: 013_restore_admin_rights.sql
-- Script to restore admin rights for user ravva@bk.ru

UPDATE user_profiles 
SET role = 'admin', updated_at = NOW()
WHERE id = (SELECT id FROM auth.users WHERE email = 'ravva@bk.ru');

INSERT INTO user_profiles (id, role, created_at, updated_at)
SELECT id, 'admin', NOW(), NOW()
FROM auth.users 
WHERE email = 'ravva@bk.ru'
AND id NOT IN (SELECT id FROM user_profiles);

-- From: 014_create_restore_function.sql
-- Function to restore admin rights for a user
CREATE OR REPLACE FUNCTION restore_admin_rights(user_email TEXT)
RETURNS TEXT AS $$
DECLARE
    user_id UUID;
    profile_exists BOOLEAN;
BEGIN
    -- Find the user ID by email
    SELECT id INTO user_id FROM auth.users WHERE email = user_email;
    
    IF user_id IS NULL THEN
        RETURN 'User not found: ' || user_email;
    END IF;
    
    -- Check if user profile already exists
    SELECT EXISTS(SELECT 1 FROM user_profiles WHERE id = user_id) INTO profile_exists;
    
    IF profile_exists THEN
        -- Update existing profile to admin
        UPDATE user_profiles 
        SET role = 'admin', updated_at = NOW()
        WHERE id = user_id;
        
        RETURN 'Admin rights restored for existing user: ' || user_email;
    ELSE
        -- Create new user profile with admin rights
        INSERT INTO user_profiles (id, role, created_at, updated_at)
        VALUES (user_id, 'admin', NOW(), NOW());
        
        RETURN 'Admin rights restored for new user: ' || user_email;
    END IF;
END;
$$ LANGUAGE plpgsql SECURITY DEFINER;

-- From: 016_add_storage_path_to_books.sql
-- Add storage_path column to books table

ALTER TABLE books
ADD COLUMN IF NOT EXISTS storage_path TEXT;

CREATE INDEX IF NOT EXISTS idx_books_storage_path ON books(storage_path);

COMMENT ON COLUMN books.storage_path IS 'Path to the book file in the S3-compatible storage bucket';

-- From: 017_add_zip_file_format.sql
-- Migration: Add support for ZIP file format

ALTER TABLE books DROP CONSTRAINT IF EXISTS books_file_format_check;
ALTER TABLE books 
ADD CONSTRAINT books_file_format_check 
CHECK (file_format IN ('fb2', 'zip'));
COMMENT ON COLUMN books.file_format IS 'Format of the book file: fb2, zip';

-- From: 018_add_telegram_file_id_unique_constraint.sql
-- Migration: Add unique constraint on telegram_file_id in books table

ALTER TABLE books 
ADD CONSTRAINT books_telegram_file_id_unique UNIQUE (telegram_file_id);
COMMENT ON CONSTRAINT books_telegram_file_id_unique ON books 
IS 'Ensures each Telegram file ID is unique in the books table';

-- From: 019_track_processed_messages.sql
-- Migration: track processed Telegram messages

CREATE TABLE IF NOT EXISTS telegram_processed_messages (
  id UUID PRIMARY KEY DEFAULT gen_random_uuid(),
  message_id TEXT NOT NULL,
  channel TEXT NOT NULL,
  book_id UUID REFERENCES books(id) ON DELETE SET NULL,
  processed_at TIMESTAMPTZ DEFAULT now(),
  created_at TIMESTAMPTZ DEFAULT now()
);

CREATE INDEX IF NOT EXISTS idx_telegram_processed_messages_message_id ON telegram_processed_messages(message_id);
CREATE INDEX IF NOT EXISTS idx_telegram_processed_messages_channel ON telegram_processed_messages(channel);
CREATE INDEX IF NOT EXISTS idx_telegram_processed_messages_book_id ON telegram_processed_messages(book_id);
CREATE INDEX IF NOT EXISTS idx_telegram_processed_messages_processed_at ON telegram_processed_messages(processed_at);

ALTER TABLE books 
ADD COLUMN IF NOT EXISTS metadata_processed BOOLEAN DEFAULT FALSE;

CREATE INDEX IF NOT EXISTS idx_books_metadata_processed ON books(metadata_processed);

-- From: 020_add_telegram_file_id_to_processed_messages.sql
-- Migration: Add telegram_file_id to telegram_processed_messages table

ALTER TABLE telegram_processed_messages 
ADD COLUMN IF NOT EXISTS telegram_file_id TEXT;

CREATE INDEX IF NOT EXISTS idx_telegram_processed_messages_telegram_file_id ON telegram_processed_messages(telegram_file_id);
COMMENT ON COLUMN telegram_processed_messages.telegram_file_id IS 'ID of the Telegram file that was processed for this message';

-- From: 023_create_telegram_stats_table.sql
-- Migration: Create telegram_stats table

CREATE TABLE IF NOT EXISTS telegram_stats (
    id UUID DEFAULT gen_random_uuid() PRIMARY KEY,
    books_in_database INTEGER DEFAULT 0,
    books_in_telegram INTEGER DEFAULT 0,
    missing_books INTEGER DEFAULT 0,
    books_without_files INTEGER DEFAULT 0,
    updated_at TIMESTAMP WITH TIME ZONE DEFAULT NOW()
);
COMMENT ON TABLE telegram_stats IS 'Stores Telegram statistics for the admin panel';

CREATE INDEX IF NOT EXISTS idx_telegram_stats_updated_at ON telegram_stats (updated_at DESC);

INSERT INTO telegram_stats (id, books_in_database, books_in_telegram, missing_books, books_without_files)
VALUES ('00000000-0000-0000-0000-000000000000', 0, 0, 0, 0)
ON CONFLICT (id) DO NOTHING;

-- From: 024_create_telegram_messages_index.sql
-- Migration: Create telegram_messages_index table

CREATE TABLE IF NOT EXISTS telegram_messages_index (
    id UUID DEFAULT gen_random_uuid() PRIMARY KEY,
    message_id TEXT NOT NULL UNIQUE,
    channel TEXT NOT NULL,
    author TEXT,
    title TEXT,
    created_at TIMESTAMPTZ DEFAULT NOW(),
    updated_at TIMESTAMPTZ DEFAULT NOW()
);

CREATE INDEX IF NOT EXISTS idx_telegram_messages_index_message_id ON telegram_messages_index(message_id);
CREATE INDEX IF NOT EXISTS idx_telegram_messages_index_channel ON telegram_messages_index(channel);
CREATE INDEX IF NOT EXISTS idx_telegram_messages_index_author ON telegram_messages_index(author);
CREATE INDEX IF NOT EXISTS idx_telegram_messages_index_title ON telegram_messages_index(title);
CREATE INDEX IF NOT EXISTS idx_telegram_messages_index_created_at ON telegram_messages_index(created_at DESC);

CREATE OR REPLACE FUNCTION update_telegram_messages_index_updated_at()
RETURNS TRIGGER AS $$
BEGIN
    NEW.updated_at = NOW();
    RETURN NEW;
END;
$$ language 'plpgsql';

CREATE TRIGGER update_telegram_messages_index_updated_at_trigger 
    BEFORE UPDATE ON telegram_messages_index
    FOR EACH ROW EXECUTE FUNCTION update_telegram_messages_index_updated_at();

COMMENT ON TABLE telegram_messages_index IS 'Stores basic information about all Telegram messages for fast lookup and new book detection';

-- From: 025_alter_telegram_messages_index_message_id_type.sql
-- Migration: Alter telegram_messages_index message_id type

ALTER TABLE telegram_messages_index 
ALTER COLUMN message_id TYPE BIGINT USING message_id::BIGINT;

DROP INDEX IF EXISTS idx_telegram_messages_index_message_id;
CREATE INDEX IF NOT EXISTS idx_telegram_messages_index_message_id ON telegram_messages_index(message_id);
COMMENT ON COLUMN telegram_messages_index.message_id IS 'Telegram message ID as BIGINT for proper numeric sorting and comparison';

-- From: 026_align_id_types.sql
-- Migration: Align ID types for consistency

ALTER TABLE public.books
ALTER COLUMN telegram_post_id TYPE BIGINT
USING telegram_post_id::BIGINT;
COMMENT ON COLUMN public.books.telegram_post_id IS 'Telegram message ID, aligned with telegram_messages_index.message_id (BIGINT)';

ALTER TABLE public.telegram_processed_messages
ALTER COLUMN message_id TYPE BIGINT
USING message_id::BIGINT;
COMMENT ON COLUMN public.telegram_processed_messages.message_id IS 'Telegram message ID, aligned with telegram_messages_index.message_id (BIGINT)';

-- End of script
