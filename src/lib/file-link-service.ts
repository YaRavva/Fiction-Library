import { createClient } from '@supabase/supabase-js';
import { FileSearchService, BookWithoutFile, TelegramFile } from './file-search-service';
import { putObject } from './s3-service';

// –ò—Å–ø–æ–ª—å–∑—É–µ–º service role key –¥–ª—è –∞–¥–º–∏–Ω—Å–∫–∏—Ö –æ–ø–µ—Ä–∞—Ü–∏–π
const supabaseUrl = process.env.NEXT_PUBLIC_SUPABASE_URL!;
const serviceRoleKey = process.env.SUPABASE_SERVICE_ROLE_KEY!;

if (!supabaseUrl || !serviceRoleKey) {
  throw new Error('Missing Supabase environment variables');
}

const supabaseAdmin = createClient(supabaseUrl, serviceRoleKey);

export interface FileLinkResult {
  success: boolean;
  bookId: string;
  fileUrl?: string;
  error?: string;
}

/**
 * –°–µ—Ä–≤–∏—Å –¥–ª—è –∑–∞–≥—Ä—É–∑–∫–∏ —Ñ–∞–π–ª–æ–≤ –≤ storage –∏ –ø—Ä–∏–≤—è–∑–∫–∏ –∫ –∫–Ω–∏–≥–∞–º
 */
export class FileLinkService {
  private static instance: FileLinkService;
  private telegramService: any;

  public static async getInstance(): Promise<FileLinkService> {
    if (!FileLinkService.instance) {
      FileLinkService.instance = new FileLinkService();
      await FileLinkService.instance.initialize();
    }
    return FileLinkService.instance;
  }

  private async initialize() {
    try {
      const { TelegramService } = await import('./telegram/client');
      this.telegramService = await TelegramService.getInstance();
    } catch (error) {
      console.error('–û—à–∏–±–∫–∞ –∏–Ω–∏—Ü–∏–∞–ª–∏–∑–∞—Ü–∏–∏ Telegram —Å–µ—Ä–≤–∏—Å–∞:', error);
      throw error;
    }
  }

  /**
   * –ó–∞–≥—Ä—É–∂–∞–µ—Ç —Ñ–∞–π–ª –∏–∑ Telegram –∏ —Å–æ—Ö—Ä–∞–Ω—è–µ—Ç –≤ storage
   */
  public async downloadAndUploadFile(
    messageId: number,
    channelId: number,
    book: BookWithoutFile
  ): Promise<{ buffer: Buffer; fileName: string; mimeType: string }> {
    try {
      console.log(`üì• –ó–∞–≥—Ä—É–∑–∫–∞ —Ñ–∞–π–ª–∞ ${messageId} –∏–∑ –∫–∞–Ω–∞–ª–∞ ${channelId}...`);

      // –ü–æ–ª—É—á–∞–µ–º —Å–æ–æ–±—â–µ–Ω–∏–µ —Å —Ñ–∞–π–ª–æ–º
      const channelEntity = await this.telegramService.getChannelEntityById(channelId);
      const message = await this.telegramService.getMessageById(channelEntity, messageId);

      if (!message) {
        throw new Error(`–°–æ–æ–±—â–µ–Ω–∏–µ ${messageId} –Ω–µ –Ω–∞–π–¥–µ–Ω–æ`);
      }

      // –ó–∞–≥—Ä—É–∂–∞–µ–º —Ñ–∞–π–ª
      const fileBuffer = await this.telegramService.downloadMedia(message);

      if (!fileBuffer || fileBuffer.length === 0) {
        throw new Error('–§–∞–π–ª –ø—É—Å—Ç–æ–π –∏–ª–∏ –Ω–µ —É–¥–∞–ª–æ—Å—å –∑–∞–≥—Ä—É–∑–∏—Ç—å');
      }

      // –û–ø—Ä–µ–¥–µ–ª—è–µ–º –∏–º—è —Ñ–∞–π–ª–∞ –∏ MIME —Ç–∏–ø
      // –ò—Å–ø–æ–ª—å–∑—É–µ–º –ø–æ–¥—Ö–æ–¥, –∞–Ω–∞–ª–æ–≥–∏—á–Ω—ã–π file-service.ts: messageId + extension
      let fileName = `${messageId}`;
      let fileExtension = '.fb2'; // –ü–æ —É–º–æ–ª—á–∞–Ω–∏—é

      const msg = message as any;
      if (msg.media && msg.media.document) {
        const document = msg.media.document;
        // –ü–æ–ª—É—á–∞–µ–º —Ä–∞—Å—à–∏—Ä–µ–Ω–∏–µ –∏–∑ –æ—Ä–∏–≥–∏–Ω–∞–ª—å–Ω–æ–≥–æ –∏–º–µ–Ω–∏ —Ñ–∞–π–ª–∞
        const docFileName = document.attributes?.find((attr: any) => attr.fileName)?.fileName;
        if (docFileName) {
          const ext = docFileName.split('.').pop();
          if (ext) {
            fileExtension = `.${ext}`;
          }
        }
      }

      // –§–æ—Ä–º–∏—Ä—É–µ–º –∏–º—è —Ñ–∞–π–ª–∞ –∫–∞–∫ messageId + extension
      fileName = `${messageId}${fileExtension}`;

      const mimeType = this.detectMimeType(fileName);

      console.log(`‚úÖ –§–∞–π–ª –∑–∞–≥—Ä—É–∂–µ–Ω: ${fileName} (${fileBuffer.length} bytes)`);

      return {
        buffer: fileBuffer,
        fileName,
        mimeType
      };
    } catch (error) {
      console.error('–û—à–∏–±–∫–∞ –ø—Ä–∏ –∑–∞–≥—Ä—É–∑–∫–µ —Ñ–∞–π–ª–∞:', error);
      throw error;
    }
  }

  /**
   * –ü–æ–ª—É—á–∞–µ—Ç –∏–Ω—Ñ–æ—Ä–º–∞—Ü–∏—é –æ —Ñ–∞–π–ª–µ –∏–∑ Telegram –±–µ–∑ –∑–∞–≥—Ä—É–∑–∫–∏
   */
  public async getFileInfo(
    messageId: number,
    channelId: number
  ): Promise<{ fileName: string; mimeType: string }> {
    try {
      console.log(`üîç –ü–æ–ª—É—á–µ–Ω–∏–µ –∏–Ω—Ñ–æ—Ä–º–∞—Ü–∏–∏ –æ —Ñ–∞–π–ª–µ ${messageId} –∏–∑ –∫–∞–Ω–∞–ª–∞ ${channelId}...`);

      // –ü–æ–ª—É—á–∞–µ–º —Å–æ–æ–±—â–µ–Ω–∏–µ —Å —Ñ–∞–π–ª–æ–º
      const channelEntity = await this.telegramService.getChannelEntityById(channelId);
      const message = await this.telegramService.getMessageById(channelEntity, messageId);

      if (!message) {
        throw new Error(`–°–æ–æ–±—â–µ–Ω–∏–µ ${messageId} –Ω–µ –Ω–∞–π–¥–µ–Ω–æ`);
      }

      // –û–ø—Ä–µ–¥–µ–ª—è–µ–º –∏–º—è —Ñ–∞–π–ª–∞ –∏ MIME —Ç–∏–ø
      // –ò—Å–ø–æ–ª—å–∑—É–µ–º –ø–æ–¥—Ö–æ–¥, –∞–Ω–∞–ª–æ–≥–∏—á–Ω—ã–π file-service.ts: messageId + extension
      let fileName = `${messageId}`;
      let fileExtension = '.fb2'; // –ü–æ —É–º–æ–ª—á–∞–Ω–∏—é

      const msg = message as any;
      if (msg.media && msg.media.document) {
        const document = msg.media.document;
        // –ü–æ–ª—É—á–∞–µ–º —Ä–∞—Å—à–∏—Ä–µ–Ω–∏–µ –∏–∑ –æ—Ä–∏–≥–∏–Ω–∞–ª—å–Ω–æ–≥–æ –∏–º–µ–Ω–∏ —Ñ–∞–π–ª–∞
        const docFileName = document.attributes?.find((attr: any) => attr.fileName)?.fileName;
        if (docFileName) {
          const ext = docFileName.split('.').pop();
          if (ext) {
            fileExtension = `.${ext}`;
          }
        }
      }

      // –§–æ—Ä–º–∏—Ä—É–µ–º –∏–º—è —Ñ–∞–π–ª–∞ –∫–∞–∫ messageId + extension
      fileName = `${messageId}${fileExtension}`;

      const mimeType = this.detectMimeType(fileName);

      console.log(`‚úÖ –ò–Ω—Ñ–æ—Ä–º–∞—Ü–∏—è –æ —Ñ–∞–π–ª–µ –ø–æ–ª—É—á–µ–Ω–∞: ${fileName}`);

      return {
        fileName,
        mimeType
      };
    } catch (error) {
      console.error('–û—à–∏–±–∫–∞ –ø—Ä–∏ –ø–æ–ª—É—á–µ–Ω–∏–∏ –∏–Ω—Ñ–æ—Ä–º–∞—Ü–∏–∏ –æ —Ñ–∞–π–ª–µ:', error);
      throw error;
    }
  }

  /**
   * –°–æ—Ö—Ä–∞–Ω—è–µ—Ç —Ñ–∞–π–ª –≤ S3 –±–∞–∫–µ—Ç
   */
  public async uploadToStorage(
    fileName: string,
    buffer: Buffer,
    mimeType: string
  ): Promise<string> {
    try {
      console.log(`‚òÅÔ∏è –ó–∞–≥—Ä—É–∑–∫–∞ —Ñ–∞–π–ª–∞ –≤ S3: ${fileName}...`);

      // –ò—Å–ø–æ–ª—å–∑—É–µ–º –∏–º—è —Ñ–∞–π–ª–∞ –∫–∞–∫ –µ—Å—Ç—å, –±–µ–∑ –¥–æ–±–∞–≤–ª–µ–Ω–∏—è –≤—Ä–µ–º–µ–Ω–Ω—ã—Ö –º–µ—Ç–æ–∫
      // –≠—Ç–æ —Å–æ–æ—Ç–≤–µ—Ç—Å—Ç–≤—É–µ—Ç –ø–æ–¥—Ö–æ–¥—É –≤ file-service.ts
      const storagePath = fileName;

      // –ó–∞–≥—Ä—É–∂–∞–µ–º —Ñ–∞–π–ª –≤ S3 –±–∞–∫–µ—Ç
      const bucketName = process.env.S3_BUCKET_NAME;
      if (!bucketName) {
        throw new Error('S3_BUCKET_NAME environment variable is not set.');
      }
      await putObject(storagePath, buffer, bucketName);

      console.log(`‚úÖ –§–∞–π–ª –∑–∞–≥—Ä—É–∂–µ–Ω –≤ S3: ${storagePath}`);

      return storagePath;
    } catch (error) {
      console.error('–û—à–∏–±–∫–∞ –ø—Ä–∏ –∑–∞–≥—Ä—É–∑–∫–µ –≤ S3:', error);
      throw error;
    }
  }

  /**
   * –ü—Ä–∏–≤—è–∑—ã–≤–∞–µ—Ç —Ñ–∞–π–ª –∫ –∫–Ω–∏–≥–µ –≤ –±–∞–∑–µ –¥–∞–Ω–Ω—ã—Ö
   */
  public async linkFileToBook(
    bookId: string,
    storagePath: string,
    fileName: string,
    fileSize: number,
    mimeType: string,
    telegramFileId?: string
  ): Promise<FileLinkResult> {
    try {
      console.log(`üîó –ü—Ä–∏–≤—è–∑–∫–∞ —Ñ–∞–π–ª–∞ –∫ –∫–Ω–∏–≥–µ ${bookId}...`);

      // –§–æ—Ä–º–∏—Ä—É–µ–º URL —Ñ–∞–π–ª–∞ –≤ S3
      const bucketName = process.env.S3_BUCKET_NAME;
      if (!bucketName) {
        throw new Error('S3_BUCKET_NAME environment variable is not set.');
      }
      const fileUrl = `https://${bucketName}.s3.cloud.ru/${storagePath}`;

      // –û–ø—Ä–µ–¥–µ–ª—è–µ–º —Ñ–æ—Ä–º–∞—Ç —Ñ–∞–π–ª–∞
      const fileFormat = this.detectFileFormat(fileName);

      // –û–±–Ω–æ–≤–ª—è–µ–º –∑–∞–ø–∏—Å—å –∫–Ω–∏–≥–∏
      const { data, error } = await supabaseAdmin
        .from('books')
        .update({
          file_url: fileUrl,
          file_size: fileSize,
          file_format: fileFormat,
          telegram_file_id: telegramFileId,
          updated_at: new Date().toISOString()
        })
        .eq('id', bookId)
        .select()
        .single();

      if (error) {
        throw new Error(`–û—à–∏–±–∫–∞ –æ–±–Ω–æ–≤–ª–µ–Ω–∏—è –∫–Ω–∏–≥–∏: ${error.message}`);
      }

      console.log(`‚úÖ –§–∞–π–ª —É—Å–ø–µ—à–Ω–æ –ø—Ä–∏–≤—è–∑–∞–Ω –∫ –∫–Ω–∏–≥–µ ${bookId}`);

      return {
        success: true,
        bookId,
        fileUrl
      };
    } catch (error) {
      console.error('–û—à–∏–±–∫–∞ –ø—Ä–∏ –ø—Ä–∏–≤—è–∑–∫–µ —Ñ–∞–π–ª–∞ –∫ –∫–Ω–∏–≥–µ:', error);

      return {
        success: false,
        bookId,
        error: error instanceof Error ? error.message : '–ù–µ–∏–∑–≤–µ—Å—Ç–Ω–∞—è –æ—à–∏–±–∫–∞'
      };
    }
  }

  /**
   * –ü—Ä–∏–≤—è–∑—ã–≤–∞–µ—Ç —É–∂–µ —Å—É—â–µ—Å—Ç–≤—É—é—â–∏–π —Ñ–∞–π–ª –≤ storage –∫ –∫–Ω–∏–≥–µ
   */
  public async linkExistingFileToBook(
    bookId: string,
    storagePath: string,
    fileName: string,
    mimeType: string,
    // –î–æ–±–∞–≤–ª—è–µ–º –ø–∞—Ä–∞–º–µ—Ç—Ä—ã –¥–ª—è –ø—Ä–æ–≤–µ—Ä–∫–∏ —Å–æ–æ—Ç–≤–µ—Ç—Å—Ç–≤–∏—è
    expectedFileSize?: number,
    expectedFileExtension?: string
  ): Promise<FileLinkResult> {
    try {
      console.log(`üîó –ü—Ä–∏–≤—è–∑–∫–∞ —Å—É—â–µ—Å—Ç–≤—É—é—â–µ–≥–æ —Ñ–∞–π–ª–∞ –∫ –∫–Ω–∏–≥–µ ${bookId}...`);

      // –§–æ—Ä–º–∏—Ä—É–µ–º URL —Ñ–∞–π–ª–∞ –≤ S3
      const bucketName = process.env.S3_BUCKET_NAME;
      if (!bucketName) {
        throw new Error('S3_BUCKET_NAME environment variable is not set.');
      }
      const fileUrl = `https://${bucketName}.s3.cloud.ru/${storagePath}`;

      // –û–ø—Ä–µ–¥–µ–ª—è–µ–º —Ñ–æ—Ä–º–∞—Ç —Ñ–∞–π–ª–∞
      const fileFormat = this.detectFileFormat(fileName);

      // –û–±–Ω–æ–≤–ª—è–µ–º –∑–∞–ø–∏—Å—å –∫–Ω–∏–≥–∏
      const { data, error } = await supabaseAdmin
        .from('books')
        .update({
          file_url: fileUrl,
          file_size: expectedFileSize || 0,
          file_format: fileFormat,
          updated_at: new Date().toISOString()
        })
        .eq('id', bookId)
        .select()
        .single();

      if (error) {
        throw new Error(`–û—à–∏–±–∫–∞ –æ–±–Ω–æ–≤–ª–µ–Ω–∏—è –∫–Ω–∏–≥–∏: ${error.message}`);
      }

      console.log(`‚úÖ –°—É—â–µ—Å—Ç–≤—É—é—â–∏–π —Ñ–∞–π–ª —É—Å–ø–µ—à–Ω–æ –ø—Ä–∏–≤—è–∑–∞–Ω –∫ –∫–Ω–∏–≥–µ ${bookId}`);

      return {
        success: true,
        bookId,
        fileUrl
      };
    } catch (error) {
      console.error('–û—à–∏–±–∫–∞ –ø—Ä–∏ –ø—Ä–∏–≤—è–∑–∫–µ —Å—É—â–µ—Å—Ç–≤—É—é—â–µ–≥–æ —Ñ–∞–π–ª–∞ –∫ –∫–Ω–∏–≥–µ:', error);

      return {
        success: false,
        bookId,
        error: error instanceof Error ? error.message : '–ù–µ–∏–∑–≤–µ—Å—Ç–Ω–∞—è –æ—à–∏–±–∫–∞'
      };
    }
  }

  /**
   * –í—ã–ø–æ–ª–Ω—è–µ—Ç –ø–æ–ª–Ω—ã–π –ø—Ä–æ—Ü–µ—Å—Å: –∑–∞–≥—Ä—É–∑–∫–∞ —Ñ–∞–π–ª–∞ –∏ –ø—Ä–∏–≤—è–∑–∫–∞ –∫ –∫–Ω–∏–≥–µ
   */
  public async processFileForBook(
    messageId: number,
    channelId: number,
    book: BookWithoutFile
  ): Promise<FileLinkResult> {
    try {
      console.log(`üöÄ –ù–∞—á–∞–ª–æ –æ–±—Ä–∞–±–æ—Ç–∫–∏ —Ñ–∞–π–ª–∞ –¥–ª—è –∫–Ω–∏–≥–∏: ${book.title} - ${book.author}`);

      // –®–∞–≥ 1: –ó–∞–≥—Ä—É–∂–∞–µ–º —Ñ–∞–π–ª –∏–∑ Telegram
      const { buffer, fileName, mimeType } = await this.downloadAndUploadFile(
        messageId,
        channelId,
        book
      );

      // –®–∞–≥ 2: –ó–∞–≥—Ä—É–∂–∞–µ–º –≤ storage
      const storagePath = await this.uploadToStorage(fileName, buffer, mimeType);

      // –®–∞–≥ 3: –ü—Ä–∏–≤—è–∑—ã–≤–∞–µ–º –∫ –∫–Ω–∏–≥–µ
      const result = await this.linkFileToBook(
        book.id,
        storagePath,
        fileName,
        buffer.length,
        mimeType
      );

      if (result.success) {
        console.log(`‚úÖ –§–∞–π–ª —É—Å–ø–µ—à–Ω–æ –æ–±—Ä–∞–±–æ—Ç–∞–Ω –∏ –ø—Ä–∏–≤—è–∑–∞–Ω –∫ –∫–Ω–∏–≥–µ`);
      }

      return result;
    } catch (error) {
      console.error('–û—à–∏–±–∫–∞ –ø—Ä–∏ –æ–±—Ä–∞–±–æ—Ç–∫–µ —Ñ–∞–π–ª–∞:', error);

      return {
        success: false,
        bookId: book.id,
        error: error instanceof Error ? error.message : '–ù–µ–∏–∑–≤–µ—Å—Ç–Ω–∞—è –æ—à–∏–±–∫–∞'
      };
    }
  }

  /**
   * –û—á–∏—â–∞–µ—Ç –∏–º—è —Ñ–∞–π–ª–∞ –æ—Ç –Ω–µ–¥–æ–ø—É—Å—Ç–∏–º—ã—Ö —Å–∏–º–≤–æ–ª–æ–≤
   */
  private sanitizeFileName(fileName: string): string {
    return fileName
      .replace(/[<>:"/\\|?*]/g, '_') // –ó–∞–º–µ–Ω—è–µ–º –Ω–µ–¥–æ–ø—É—Å—Ç–∏–º—ã–µ —Å–∏–º–≤–æ–ª—ã
      .replace(/\s+/g, '_') // –ó–∞–º–µ–Ω—è–µ–º –ø—Ä–æ–±–µ–ª—ã –Ω–∞ –ø–æ–¥—á–µ—Ä–∫–∏–≤–∞–Ω–∏—è
      .substring(0, 100); // –û–≥—Ä–∞–Ω–∏—á–∏–≤–∞–µ–º –¥–ª–∏–Ω—É
  }

  /**
   * –û–ø—Ä–µ–¥–µ–ª—è–µ—Ç MIME —Ç–∏–ø –ø–æ –∏–º–µ–Ω–∏ —Ñ–∞–π–ª–∞
   */
  private detectMimeType(fileName: string): string {
    const ext = fileName.toLowerCase().split('.').pop();

    switch (ext) {
      case 'fb2':
        return 'application/fb2';
      case 'epub':
        return 'application/epub+zip';
      case 'pdf':
        return 'application/pdf';
      case 'txt':
        return 'text/plain';
      case 'zip':
        return 'application/zip';
      case 'rar':
        return 'application/x-rar-compressed';
      default:
        return 'application/octet-stream';
    }
  }

  /**
   * –û–ø—Ä–µ–¥–µ–ª—è–µ—Ç —Ñ–æ—Ä–º–∞—Ç —Ñ–∞–π–ª–∞ –ø–æ –∏–º–µ–Ω–∏
   */
  private detectFileFormat(fileName: string): string {
    const ext = fileName.toLowerCase().split('.').pop();

    switch (ext) {
      case 'fb2':
        return 'fb2';
      case 'epub':
        return 'epub';
      case 'pdf':
        return 'pdf';
      case 'txt':
        return 'txt';
      case 'zip':
        return 'zip';
      case 'rar':
        return 'rar';
      default:
        return 'fb2'; // –ü–æ —É–º–æ–ª—á–∞–Ω–∏—é —Å—á–∏—Ç–∞–µ–º fb2
    }
  }
}